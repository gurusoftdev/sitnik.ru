#!/usr/bin/env node

let { existsSync } = require('fs')
let { writeFile } = require('fs').promises
let { join } = require('path')

let callCloudflare = require('./lib/call-cloudflare')
let loadSecrets = require('./lib/load-secrets')
let MyError = require('./lib/my-error')
let read = require('./lib/read')
let get = require('./lib/get')

const LAST = join(__dirname, 'location', 'last.json')
const RU = join(__dirname, '..', 'dist', 'ru', 'index.html')
const EN = join(__dirname, '..', 'dist', 'en', 'index.html')

async function loadLocation () {
  return get('https://evilmartians.com/locations/ai')
}

async function wasNotChanged (cur) {
  if (!existsSync(LAST)) return false
  let last = JSON.parse(await read(LAST))
  if (cur.latitude === last.latitude && cur.longitude === last.longitude) {
    process.stdout.write('Location was not changed\n')
    return true
  } else {
    return false
  }
}

async function saveLast (location) {
  await writeFile(LAST, JSON.stringify(location))
}

async function cleanCache (token) {
  if (process.argv.includes('--no-cdn')) return
  let zone = 'b907f2f99f46af59bf282e3d97a654bc'
  await callCloudflare(zone, token, 'purge_cache', {
    files: ['https://sitnik.ru/ru/', 'https://sitnik.ru/en/']
  })
}

async function processCity (token, html, location) {
  let lang = html.includes(' lang="ru"') ? 'ru' : 'en'

  let geodata = await get(
    'https://maps.googleapis.com/maps/api/geocode/json' +
    `?latlng=${ location.latitude },${ location.longitude }` +
    `&language=${ lang }` +
    `&key=${ token }`
  )
  let address = geodata.results[0].address_components
  let country = address.find(i => i.types.includes('country'))
  let city = address.find(i => i.types.includes('locality'))

  if (country.short_name === 'JP') {
    if (address.find(i => i.short_name === 'Tōkyō-to')) {
      city = { long_name: lang === 'ru' ? 'Токио' : 'Tokyo' }
    }
  } else if (country.short_name === 'US') {
    country = { long_name: lang === 'ru' ? 'США' : 'USA' }
  }
  if (!city) {
    city = address.find(i => i.types.includes('administrative_area_level_1'))
  }
  if (city.long_name === 'New York' && lang === 'ru') {
    city.long_name = 'Нью-Йорк'
  }

  process.stdout.write(`${ city.long_name }, ${ country.long_name }\n`)

  html = html
    .replace(
      /<([^>]+) itemprop="addressLocality"([^>]?)>[^<]+<\/([^>]+)>/,
      `<$1 itemprop="addressLocality"$2>${ city.long_name }</$3>`
    )
    .replace(
      /<([^>]+) itemprop="addressCountry"([^>]?)>[^<]+<\/([^>]+)>/,
      `<$1 itemprop="addressLocality"$2>${ country.long_name }</$3>`
    )
    .replace(/ data-lat="([^"])+"/, ` data-lat="${ location.latitude }"`)
    .replace(/ data-lng="([^"])+"/, ` data-lng="${ location.longitude }"`)

  await writeFile(lang === 'ru' ? RU : EN, html)
}

if (process.argv.includes('--clean-cdn')) {
  loadSecrets()
    .then(async secrets => {
      await cleanCache(secrets.cloudflare)
    })
    .catch(MyError.print)
} else {
  Promise
    .all([loadSecrets(), read(RU), read(EN), loadLocation()])
    .then(async ([secrets, htmlRu, htmlEn, location]) => {
      if (await wasNotChanged(location)) return
      await Promise.all([
        processCity(secrets.gmaps, htmlRu, location),
        processCity(secrets.gmaps, htmlEn, location)
      ])
      await cleanCache(secrets.cloudflare)
      await saveLast(location)
    })
    .catch(MyError.print)
}
